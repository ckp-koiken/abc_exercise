#include <bits/stdc++.h>
using namespace std;

// nから2つを選んだ組み合わせnC2を求める関数
int64_t c2(int64_t n) {
  return n * (n - 1) / 2;
}

// 正攻法はiとjそれぞれについて二重ループを実装し
// 元の文字列と異なる文字列の数を調べること
// しかし計算量が多すぎてTLEする

// 交換する2文字に着目する
// 交換する文字i, jが異なれば交換後の文字列は交換前のそれと異なる
// 交換する文字i, jが同じであれば交換後の文字列は交換前と同じである
int main() {
  string S;
  cin >> S;

  int n = S.size();

  // 交換後も同じであるようなペアの数
  int64_t same = 0;

  // 文字列の中の文字の分布を求める
  // どの文字が何文字出てくるか
  map<char, int> cnt;
  for (char c : S) cnt[c]++;

  // 各文字の登場回数を見る
  for (auto p : cnt) {
    int m = p.second;
    // 登場回数をmとするとき2文字選んだ組み合わせ
    // mC2の数だけ交換後も同じになる
    // mC2を求める関数c2を実装しておく
    same += c2(m);
  }

  // よって交換後も異なる文字列は、文字列全体から2文字選んだ組み合わせ総数から
  // 同じ2文字を選んだ場合の数を引いたものになる
  int64_t diff = c2(n) - same;
  int64_t ans = diff;

  // 同じ2文字を選んだ場合は元と同じ文字列ができる
  // 元と同じ文字列が1つだけできているため、
  // sameが>1なら答えを1つ足す
  // 「操作後」の文字列としてあり得るものを求めるから。
  if (same) ans++;

  cout << ans << endl;

  return 0;
}