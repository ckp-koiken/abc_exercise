#include <bits/stdc++.h>
using namespace std;

// 問題文の通りに4つ同じ数字が登場して消せる場所を全て組み合わせを探すと
// 計算量が多すぎてTLEとなる...O(N^2)
// Nの最大値が2*10^5なので4*10^10となってしまう。10^8くらいにしたいところ。
// そこでスタックを使って計算量を節約する
// 与えられた数列を順番にベクタに追加していって4つ並んだところで後ろから4つを削除する
// 後ろの要素を削除する分には計算量が多くならない（先頭とか前の方を削除すると多くなる）
// 順番に追加して後ろから削除するだけなので計算量はO(N)
int main() {
  int N;
  cin >> N;
  // スタック用のベクタを用意
  vector<int> s;
  
  for (int i = 0; i < N; i++) {
    // 読んだ整数をスタックに積んでいく
    int a;
    cin >> a;
    s.push_back(a);

    // sの大きさが4未満だと配列外参照をするのでサイズを4以上に制限
    if (s.size() >= 4) {
      // 連続する4要素が全部同じかを判定
      bool ok = true;

      // 末尾とその他3つを比較するので3回ループさせる
      for (int j = 0; j < 3; j++) {
        // 末尾要素とその前3つを比較して等しいかどうかを確認
        // 4要素の配列ならば末尾の添え字は3で、その一つ前から確認するので-2
        if (s[s.size() - 2 - j] != s.back()) {
          // 等しくなかったらfalseに
          ok = false;
        }
      }

      // okがtrue（連続する4要素が同じ）なら後ろ4つを削除する
      if (ok) {
        for (int j = 0; j < 4; j++) {
          s.pop_back();
        }
      }
    }
  }

  // 最終的に残ったsの大きさを出力
  cout << s.size() << endl;
  return 0;
}