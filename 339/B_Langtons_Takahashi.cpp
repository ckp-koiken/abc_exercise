#include <bits/stdc++.h>
using namespace std;

// 指定された進行方向に座標を進めるための配列を用意する
const int di[] = {-1, 0, 1, 0};
const int dj[] = {0, 1, 0, -1};

int main() {
  int H, W, N;
  cin >> H >> W >> N;
  vector<string> S(H, string(W, '.'));

  // 座標i, jと進行方向vを管理して手続きをN回シミュレーションする
  // 進行方向vは上方向を0として時計回りに1ずつ増える（最大値が3）
  int i = 0, j = 0, v = 0;
  for (int ti = 0; ti < N; ti++) {
    if (S.at(i).at(j) == '.') {
      // 現在位置が白なら黒に塗り替える
      S.at(i).at(j) = '#';
      // 進行方向を時計回りに90度進める
      v += 1;
    } else {
      // 現在位置が黒なら白に塗り替える
      S.at(i).at(j) = '.';
      // 進行方向を反時計回りに90度進める
      // 時計回りに270度進めるのと同じなので3を足す
      v += 3;
    }
    // 進行方向を4で割った余りとする（0～3）
    v %= 4;
    // 進行方向に座標を変えるための配列di、djを用意しておく
    // 添え字vに対応した数だけ座標i, jを進める
    i += di[v];
    j += dj[v];

    // 座標はトーラス状なので上下左右の端まで行ったら
    // 反対側の端から移動する
    // i, jをH, Wで割った余りを座標として扱う
    // C++は割られる数が負だと余りが変な値になるのでわざわざHかWを足しておく
    i = (i + H) % H;
    j = (j + W) % W;
  }

  for (int i = 0; i < H; i++) {
    cout << S.at(i) << endl;
  }
  return 0;
}