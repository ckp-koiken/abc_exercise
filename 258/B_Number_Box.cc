#include <bits/stdc++.h>
using namespace std;

// まずどのマスから出発するかを全探索する
// 次に進む方向を全探索する
// 進んだ順に並べた整数が確定し、その最大値を求める
int main() {
  int N;
  cin >> N;

  // 答えの桁が大きくなるので64bit整数を用意
  int64_t ans = 0;

  // 二次元配列に読み込む
  vector<vector<int64_t>> A(N, vector<int64_t>(N));
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
      // 一文字ずつ整数を読み込むために一度charに読んでから
      // 整数に変換する
      char c;
      cin >> c;
      A[i][j] = c - '0';
    }
  }

  // 進行方向8方向を示す配列
  // 右下、右、右上、下、上、左上、左、左下
  vector<int> p = {1, 1, 1, 0, 0, -1, -1, -1}; // x
  vector<int> q = {1, 0, -1, 1, -1, 1, 0, -1}; // y

  // 二次元配列を全探索して始点を見つける
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {

      // 8方向の移動を探索
      for (int k = 0; k < 8; k++) {
        int64_t now = 0;  // 現在作っている数
        int64_t x = i, y = j; // x, yは今いるマス

        // 進行をN回繰り返す
        // 進行はN-1回だが最初のマスの処理をするのでN回
        for (int l = 0; l < N; l++) {
          now *= 10;  // 10倍して1桁左シフト（桁を増やす）
          now += A[x][y]; // 今いるx,y座標の数字を末尾に加える
          x += p[k]; // k方向へのx座標の移動を反映
          y += q[k]; // k方向へのy座標の移動を反映
          x %= N; // 移動を続けるとはみ出すので剰余を取る
          x += N; // 負の値になるのを避けるためNを足す
          y %= N; // yも同様
          y += N;
          x %= N; // 非負にしたところでもう一度剰余を取る
          y %= N;

          // x = (x % N + N) % N
          // y = (y % N + N) % N
          // としてもOK
          // x, yが大きな数字でも負の数を取らないように
          // 二回剰余を取っている
        }

        // 出来た数字の最大値を更新し続ける
        ans = max(ans, now);
      }
    }
  }

  cout << ans << endl;

  return 0;
}
